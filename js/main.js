import { logger } from '../utils/logger.js';

// Rune Engine core module - integrates automatic rune generation features.

// Global state holders that can be shared across modules.
let runeManager = null;
let workspaceManager = null;
let autoRuneGenerator = null;

// Export handles so other modules can reuse shared state when needed.
export { runeManager, workspaceManager, autoRuneGenerator };

const LOG_TAG = 'Main';

/**
 * Initialize workspace helpers and expose persistent rune utilities.
 */
function initWorkspaceManager() {
  // Initialize rune manager.
  if (typeof RuneManager !== 'undefined') {
    runeManager = new RuneManager();
    logger.info(LOG_TAG, 'Rune manager ready');
  } else {
    logger.error(LOG_TAG, 'RuneManager class is not defined');
  }

  // Prepare workspace manager bindings.
  workspaceManager = {
    // Set the default workspace path that desktop builds expect.
    currentPath: 'D:\\YinGAN-RuneEngine\\myrune',

    /**
     * Persist rune data and related media files into the workspace folder.
     * @param {object} rune - Rune payload produced by the generator.
     * @param {FileList|File[]} files - Optional media assets to store together.
     * @returns {Promise<{success: boolean, runeId?: string, filePath?: string, error?: string}>}
     */
    saveRune: async function(rune, files) {
      logger.info(LOG_TAG, `Saving rune to workspace: ${rune.name}`);

      try {
        // Ensure the workspace folder hierarchy exists.
        await this.ensureWorkspaceDirectory();

        // Generate a unique rune identifier.
        const runeId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        // Save the rune JSON file into the rune subfolder.
        const runeFileName = `rune_${runeId}.json`;
        const runeFilePath = `${this.currentPath}\\rune\\${runeFileName}`;

        // Prepare rune data package (including multimodal content).
        const runeData = {
          id: runeId,
          name: rune.name,
          timestamp: new Date().toISOString(),
          nineGrid: rune.nineGrid,
          multimodalContent: rune.nineGrid.content || {},
          unifiedVector: rune.unifiedVector || null,
          _fallback: rune._fallback || false,
          metadata: {
            fileCount: files ? files.length : 0,
            originalFiles: files ? files.map(f => f.name) : [],
            version: '1.0'
          }
        };

        // Use Node.js fs module when available (Electron or desktop builds).
        if (typeof window.require !== 'undefined') {
          const fs = window.require('fs').promises;
          await fs.writeFile(runeFilePath, JSON.stringify(runeData, null, 2), 'utf8');
          logger.info(LOG_TAG, `Rune JSON saved at ${runeFilePath}`);
        } else {
          // Fallback for browsers: trigger file download.
          this.downloadFile(runeData, runeFileName);
        }

        // Save additional media assets into the media subfolder.
        if (files && files.length > 0) {
          await this.saveMediaFiles(files, runeId);
        }

        // Refresh workspace status in the UI.
        this.updateWorkspaceStatus();

        logger.info(LOG_TAG, `Rune stored successfully. ID: ${runeId}`);
        return { success: true, runeId: runeId, filePath: runeFilePath };

      } catch (error) {
        logger.error(LOG_TAG, error);
        this.showError('Á¨¶Êñá‰øùÂ≠òÂ§±Ë¥•: ' + error.message);
        return { success: false, error: error.message };
      }
    },

    /**
     * Ensure the workspace folder hierarchy exists when running in Node contexts.
     */
    ensureWorkspaceDirectory: async function() {
      try {
        if (typeof window.require !== 'undefined') {
          const fs = window.require('fs').promises;
          const path = window.require('path');

          // Create the primary workspace directory if needed.
          try {
            await fs.access(this.currentPath);
          } catch {
            await fs.mkdir(this.currentPath, { recursive: true });
            logger.info(LOG_TAG, `Workspace directory created: ${this.currentPath}`);
          }

          // Create rune subdirectory.
          const runeDir = path.join(this.currentPath, 'rune');
          try {
            await fs.access(runeDir);
          } catch {
            await fs.mkdir(runeDir, { recursive: true });
            logger.info(LOG_TAG, `Rune directory created: ${runeDir}`);
          }

          // Create media subdirectory.
          const mediaDir = path.join(this.currentPath, 'media');
          try {
            await fs.access(mediaDir);
          } catch {
            await fs.mkdir(mediaDir, { recursive: true });
            logger.info(LOG_TAG, `Media directory created: ${mediaDir}`);
          }
        }
      } catch (error) {
        logger.error(LOG_TAG, error);
        throw error;
      }
    },

    /**
     * Store media files on disk when the desktop APIs are available.
     * @param {FileList|File[]} files - Media assets selected by the user.
     * @param {string} runeId - Identifier used to build file names.
     */
    saveMediaFiles: async function(files, runeId) {
      try {
        if (typeof window.require !== 'undefined') {
          const fs = window.require('fs').promises;
          const path = window.require('path');
          
          for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const fileExt = path.extname(file.name);
            const mediaFileName = `media_${runeId}_${i}${fileExt}`;
            const mediaFilePath = path.join(this.currentPath, 'media', mediaFileName);

            // Persist binary content to disk.
            const fileBuffer = await file.arrayBuffer();
            await fs.writeFile(mediaFilePath, Buffer.from(fileBuffer));
            logger.info(LOG_TAG, `Media file saved: ${mediaFilePath} (${file.name})`);
          }
        }
      } catch (error) {
        logger.error(LOG_TAG, error);
      }
    },

    /**
     * Provide a download fallback when running in pure browser environments.
     * @param {object} data - Rune payload to serialize.
     * @param {string} fileName - Suggested download file name.
     */
    downloadFile: function(data, fileName) {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      logger.info(LOG_TAG, `Rune downloaded: ${fileName}`);
    },

    /**
     * Refresh workspace status block to reflect the active directory.
     */
    updateWorkspaceStatus: function() {
      const statusElement = document.getElementById('workspaceStatus');
      if (statusElement) {
        statusElement.innerHTML = `
          <div style="padding: 8px; background: #e8f5e8; border: 1px solid #4caf50; border-radius: 6px; font-size: 14px;">
            <strong>üè† Â∑•‰ΩúÂå∫:</strong> ${this.currentPath}
            <br><small style="color: #666;">‚úÖ Á¨¶ÊñáÂèØ‰øùÂ≠òÂà∞Ê≠§ÁõÆÂΩï</small>
          </div>
        `;
      }
    },

    /**
     * Display workspace errors inside the UI and clear them after a timeout.
     * @param {string} message - Human readable error description.
     */
    showError: function(message) {
      const errorElement = document.getElementById('workspaceError');
      if (errorElement) {
        errorElement.innerHTML = `
          <div style="padding: 10px; background: #ffeaea; border: 1px solid #f44336; border-radius: 4px; margin: 10px 0; color: #d32f2f;">
            <strong>‚ùå ÈîôËØØ:</strong> ${message}
          </div>
        `;
        // Clear the error message after a short delay.
        setTimeout(() => {
          errorElement.innerHTML = '';
        }, 3000);
      }
    }
  };

  logger.info(LOG_TAG, 'Workspace helpers initialized');
}

/**
 * Dynamically load the auto rune generator module and expose it for later calls.
 */
async function initAutoRuneGenerator() {
  try {
    // Attempt dynamic import of the auto rune generator module.
    try {
      const module = await import('./auto-rune-generator.js');
      autoRuneGenerator = module.autoRuneGenerator;
      logger.info(LOG_TAG, 'Auto rune generator loaded');
    } catch (importError) {
      logger.error(LOG_TAG, importError);
      // Fallback: attempt to locate a global implementation exposed elsewhere.
      if (typeof window.autoRuneGenerator === 'function') {
        autoRuneGenerator = window.autoRuneGenerator;
        logger.info(LOG_TAG, 'Using global autoRuneGenerator fallback');
      } else {
        logger.error(LOG_TAG, 'Auto rune generator missing');
      }
    }
  } catch (error) {
    logger.error(LOG_TAG, error);
  }
}

/**
 * Handle the auto rune generation workflow triggered by the UI button.
 */
async function handleAutoRuneGeneration() {
  logger.info(LOG_TAG, 'Starting auto rune generation flow');
  
  // Ensure the auto rune generator module is ready.
  if (!autoRuneGenerator) {
    alert('‚ùå Ëá™Âä®Á¨¶ÊñáÁîüÊàêÂô®Â∞öÊú™Âä†ËΩΩÂÆåÊàêÔºåËØ∑Á®çÂêéÂÜçËØï');
    return;
  }

  // Ensure the rune manager exists before generating data.
  if (!runeManager) {
    alert('‚ùå Á¨¶ÊñáÁÆ°ÁêÜÂô®Êú™ÂàùÂßãÂåñÔºåÊó†Ê≥ïÁîüÊàêÁ¨¶Êñá');
    return;
  }

  // Locate the input controls used by the simplified layout.
  const fileInput = document.getElementById('fileInput');
  const runeNameInput = document.getElementById('runeName');
  const runeDescInput = document.getElementById('runeDesc');

  // Resolve the first selected file from the input element.
  let selectedFile = null;
  if (fileInput && fileInput.files && fileInput.files.length > 0) {
    selectedFile = fileInput.files[0];
    logger.info(LOG_TAG, `Selected file: ${selectedFile.name}`);
  }

  // Abort early if no file was selected.
  if (!selectedFile) {
    alert('‚ùå ËØ∑ÂÖàÈÄâÊã©‰∏Ä‰∏™Êñá‰ª∂ÔºàÂõæÁâá„ÄÅÈü≥È¢ë„ÄÅËßÜÈ¢ëÊàñÊñáÊú¨Êñá‰ª∂Ôºâ');
    return;
  }

  // Collect optional rune metadata from the form.
  const runeName = runeNameInput ? runeNameInput.value.trim() : '';
  const runeDesc = runeDescInput ? runeDescInput.value.trim() : '';

  // Update the progress indicator while processing.
  const progressText = document.getElementById('progressText');
  if (progressText) {
    progressText.textContent = 'ü§ñ AIÊ≠£Âú®ÁêÜËß£Êñá‰ª∂ÂÜÖÂÆπ...';
  }

  try {
    logger.info(LOG_TAG, 'Invoking auto rune generator');
    logger.info(LOG_TAG, `File name: ${selectedFile.name}`);
    logger.info(LOG_TAG, `File type: ${selectedFile.type}`);
    logger.info(LOG_TAG, `File size: ${(selectedFile.size / 1024).toFixed(2)} KB`);
    if (runeName) {
      logger.info(LOG_TAG, `Rune name preset: ${runeName}`);
    }
    if (runeDesc) {
      logger.info(LOG_TAG, `Rune description preset: ${runeDesc}`);
    }
    
    // Run the generator with the optional name and description.
    const generatedRune = await autoRuneGenerator(
      selectedFile,
      runeDesc, // Use the description field as additional context.
      runeManager,
      workspaceManager
    );

    // Update the rune name if the user provided one.
    if (runeName && generatedRune) {
      generatedRune.name = runeName;
    }

    logger.info(LOG_TAG, 'Auto rune generation completed');
    logger.info(LOG_TAG, `Rune name: ${generatedRune.name}`);
    logger.info(LOG_TAG, `Rune intent: ${generatedRune.nineGrid.core.intent}`);
    logger.info(LOG_TAG, `Rune essence: ${generatedRune.nineGrid.core.essence}`);
    logger.info(LOG_TAG, `Rune emotion: ${generatedRune.nineGrid.metadata.emotion}`);
    logger.info(LOG_TAG, `Rune keywords: ${generatedRune.nineGrid.metadata.keywords.join(', ')}`);
    
    // Reflect completion inside the progress indicator.
    if (progressText) {
      progressText.textContent = `‚úÖ Á¨¶Êñá„Äå${generatedRune.name}„ÄçÁîüÊàêÂÆåÊàêÔºÅ`;
    }

    // Render the generated rune inside the UI when helpers are available.
    if (typeof displayRune === 'function') {
      displayRune(generatedRune);
    }

    // Refresh the rune library list to include the new entry.
    if (typeof updateRuneLibraryList === 'function') {
      updateRuneLibraryList();
    }

    // Provide a success alert summarizing the generated rune.
    setTimeout(() => {
      alert(`üéâ Á¨¶Êñá„Äå${generatedRune.name}„ÄçËá™Âä®ÁîüÊàêÂÆåÊàêÔºÅ\n\n` +
            `üéØ ÊÑèÂõæÔºö${generatedRune.nineGrid.core.intent}\n` +
            `üíé Êú¨Ë¥®Ôºö${generatedRune.nineGrid.core.essence}\n` +
            `üòä ÊÉÖÊÑüÔºö${generatedRune.nineGrid.metadata.emotion}`);
    }, 100);
    
  } catch (error) {
    logger.error(LOG_TAG, error);
    
    // Êõ¥Êñ∞ËøõÂ∫¶‰ø°ÊÅØ
    if (progressText) {
      progressText.textContent = '‚ùå Á¨¶ÊñáÁîüÊàêÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÊéßÂà∂Âè∞Êó•Âøó';
    }
    
    // ÊòæÁ§∫ÈîôËØØÊèêÁ§∫
    alert(`‚ùå Á¨¶ÊñáÁîüÊàêÂ§±Ë¥•Ôºö${error.message}\n\n` +
          'ËØ∑Ê£ÄÊü•Ôºö\n' +
          '1. Êñá‰ª∂Ê†ºÂºèÊòØÂê¶ÊîØÊåÅ\n' +
          '2. ÁΩëÁªúËøûÊé•ÊòØÂê¶Ê≠£Â∏∏\n' +
          '3. Gemini APIÊòØÂê¶ÂèØÁî®\n' +
          '4. ÊéßÂà∂Âè∞‰∏≠ÁöÑËØ¶ÁªÜÈîôËØØ‰ø°ÊÅØ');
  }
}

// ÁªëÂÆöËá™Âä®Á¨¶ÊñáÁîüÊàê‰∫ã‰ª∂ÔºàÈÄÇÈÖçÁ≤æÁÆÄÁâàÂ∏ÉÂ±ÄÔºâ
function bindAutoRuneEvents() {
  console.log('üîß ÁªëÂÆöËá™Âä®Á¨¶ÊñáÁîüÊàê‰∫ã‰ª∂ÔºàÁ≤æÁÆÄÁâàÂ∏ÉÂ±ÄÔºâ...');
  
  // ÁªëÂÆöËá™Âä®Á¨¶ÊñáÁîüÊàêÊåâÈíÆÁÇπÂáª‰∫ã‰ª∂
  const autoGenerateBtn = document.getElementById('autoGenerateBtn');
  if (autoGenerateBtn) {
    autoGenerateBtn.addEventListener('click', handleAutoRuneGeneration);
    console.log('‚úÖ Ëá™Âä®Á¨¶ÊñáÁîüÊàêÊåâÈíÆ‰∫ã‰ª∂ÁªëÂÆöÂÆåÊàê');
  } else {
    console.warn('‚ö†Ô∏è Êú™ÊâæÂà∞Ëá™Âä®Á¨¶ÊñáÁîüÊàêÊåâÈíÆÂÖÉÁ¥†');
  }
  
  // ‰∏∫Êñá‰ª∂ËæìÂÖ•Ê∑ªÂä†ÂèòÂåñÁõëÂê¨ÔºåÊèê‰æõÂç≥Êó∂ÂèçÈ¶àÔºàÁ≤æÁÆÄÁâàÂ∏ÉÂ±ÄÔºâ
  const fileInput = document.getElementById('fileInput');
  if (fileInput) {
    fileInput.addEventListener('change', function() {
      if (this.files && this.files.length > 0) {
        const file = this.files[0];
        console.log(`üìÅ Êñá‰ª∂Â∑≤ÈÄâÊã©:`, file.name);
        
        // Êõ¥Êñ∞ËøõÂ∫¶ÊñáÊú¨ÊòæÁ§∫
        const progressText = document.getElementById('progressText');
        if (progressText) {
          progressText.textContent = `üìÅ Â∑≤ÈÄâÊã©Êñá‰ª∂Ôºö${file.name}`;
        }
      }
    });
  }
  
  // ‰∏∫Á¨¶ÊñáÂêçÁß∞ËæìÂÖ•Ê∑ªÂä†ÂõûËΩ¶Âø´Êç∑ÁîüÊàêÔºàÊñ∞Â¢ûÂäüËÉΩÔºâ
  const runeNameInput = document.getElementById('runeName');
  if (runeNameInput) {
    runeNameInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        // ÂõûËΩ¶Êó∂Ëß¶ÂèëÁ¨¶ÊñáÁîüÊàê
        if (autoGenerateBtn) {
          autoGenerateBtn.click();
        }
      }
    });
  }
}

// DOMÂÜÖÂÆπÂä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñÔºàÈÄÇÈÖçÁ≤æÁÆÄÁâàÂ∏ÉÂ±ÄÔºâ
document.addEventListener('DOMContentLoaded', function() {
  console.log('üöÄ DOMÂÜÖÂÆπÂä†ËΩΩÂÆåÊàêÔºåÂºÄÂßãÂàùÂßãÂåñÁ≤æÁÆÄÁâàÂ∏ÉÂ±Ä...');
  
  // Âª∂ËøüÂàùÂßãÂåñÔºåÁ°Æ‰øù‰æùËµñËÑöÊú¨Â∑≤Âä†ËΩΩ
  setTimeout(() => {
    initWorkspaceManager();
    
    // ÁªëÂÆöÂ∑•‰ΩúÂå∫‰∫ã‰ª∂
    if (typeof bindWorkspaceEvents === 'function') {
      bindWorkspaceEvents();
    }
    
    // ÁªëÂÆöËá™Âä®Á¨¶ÊñáÁîüÊàê‰∫ã‰ª∂
    bindAutoRuneEvents();
    
    // ÂàùÂßãÂåñÂµåÂÖ•ÂºèËÅäÂ§©ÂÆ§ÔºàÁ≤æÁÆÄÁâàÂ∏ÉÂ±ÄÔºâ
    initEmbeddedChat();
    
    // ÂºÇÊ≠•Âä†ËΩΩËá™Âä®Á¨¶ÊñáÁîüÊàêÂô®
    initAutoRuneGenerator();
    
    // Êõ¥Êñ∞Â∑•‰ΩúÂå∫Áä∂ÊÄÅÊòæÁ§∫
    if (workspaceManager) {
      workspaceManager.updateWorkspaceStatus();
    }
    
    console.log('üéâ Á≤æÁÆÄÁâàÂ∏ÉÂ±ÄÂàùÂßãÂåñÂÆåÊàê');
    console.log('üí° ‰ΩøÁî®ÊèêÁ§∫Ôºö');
    console.log('  - ‰∏ä‰º†Êñá‰ª∂ÂêéÁÇπÂáª"ÁîüÊàêÁ¨¶Êñá"ÊåâÈíÆËøõË°åÂÖ®Ëá™Âä®Á¨¶ÊñáÁîüÊàê');
    console.log('  - AIËÅäÂ§©ÂÆ§Â∑≤ÂµåÂÖ•Âè≥‰æßÂ∫ïÈÉ®ÔºåÂèØÈöèÊó∂‰∏éAIÂä©ÊâãÂØπËØù');
    console.log('  - ÊàñËÄÖ‰ΩøÁî®ÂéüÊúâÁöÑ"‚öôÔ∏è ÁîüÊàêÁ¨¶Êñá"ÊåâÈíÆËøõË°åÊâãÂä®Á°ÆËÆ§ÁîüÊàê');
    console.log(`üè† Â∑•‰ΩúÂå∫Ë∑ØÂæÑ: ${workspaceManager.currentPath}`);
  }, 500);
});

// Êñ∞Â¢ûÔºöÊõ¥Êñ∞‚ÄúÊàëÁöÑÁ¨¶ÊñáÂ∫ì‚ÄùÂàóË°®
function updateRuneLibraryList() {
  try {
    const listEl = document.getElementById('runeLibraryList');
    if (!listEl) return;
    if (!runeManager || typeof runeManager.getAllRunes !== 'function') {
      listEl.innerHTML = '<p class="tip">Á¨¶ÊñáÁÆ°ÁêÜÂô®Êú™ÂàùÂßãÂåñ</p>';
      return;
    }
    const runes = runeManager.getAllRunes();
    if (!runes || runes.length === 0) {
      listEl.innerHTML = '<p class="tip">ËøòÊ≤°ÊúâÁîüÊàêÁ¨¶Êñá</p>';
      return;
    }
    listEl.innerHTML = '';
    // ‰∏≠ÊñáÊ≥®ÈáäÔºöÂ∞ÜÁ¨¶ÊñáÂ∫ìÂàóË°®Ê∏≤Êüì‰∏∫Á¥ßÂáëÁöÑÊù°ÁõÆÂç°ÁâáÔºåÂåÖÂê´Â∞èlogo„ÄÅÂêçÁß∞„ÄÅËØ¶ÊÉÖ‰∏éÂà†Èô§ÊåâÈíÆ
    runes.forEach(rune => {
      const item = document.createElement('div');
      item.className = 'rune-list-item'; // Êñ∞Ê†∑ÂºèÁ±ªÔºöÁ¥ßÂáëÂàóË°®È°π
      const created = (rune.meta && rune.meta.created) || rune.timestamp || new Date().toISOString();
      const logo = (rune.nineGrid && rune.nineGrid.nine_turns && rune.nineGrid.nine_turns['2_form']) ? 'üúî' : '‚ú®'; // ‰∏≠ÊñáÊ≥®ÈáäÔºöÁÆÄÂçïÁöÑlogoÂç†‰ΩçÁ¨¶
      
      // Ëé∑ÂèñÁ¨¶ÊñáÊëòË¶Å‰ø°ÊÅØ
      const summary = rune.nineGrid?.metadata?.summary || 
                     (rune.nineGrid?.content?.text ? rune.nineGrid.content.text.substring(0, 60) + '...' : 'ÊöÇÊó†ÊèèËø∞');
      
      item.innerHTML = `
        <span class="rune-logo" title="Á¨¶ÊñáÊ†áËØÜ">${logo}</span>
        <span class="rune-name" title="${rune.name || 'Êú™ÂëΩÂêçÁ¨¶Êñá'}">${rune.name || 'Êú™ÂëΩÂêçÁ¨¶Êñá'}</span>
        <span class="rune-time">${new Date(created).toLocaleString('zh-CN')}</span>
        <div class="rune-summary">${summary}</div>
        <div class="rune-actions">
          <button class="rune-btn rune-detail" title="Êü•ÁúãËØ¶ÊÉÖ">üëÅÔ∏è</button>
          <button class="rune-btn rune-delete" title="Âà†Èô§Á¨¶Êñá">üóëÔ∏è</button>
        </div>
      `;
      // ËØ¶ÊÉÖÊåâÈíÆ‰∫ã‰ª∂ÁªëÂÆöÔºöÊâìÂºÄËØ¶ÊÉÖËßÜÂõæ
      const detailBtn = item.querySelector('.rune-detail');
      if (detailBtn) {
        detailBtn.addEventListener('click', () => displayRune(rune));
      }
      // Âà†Èô§ÊåâÈíÆ‰∫ã‰ª∂ÁªëÂÆöÔºöÂà†Èô§Á¨¶ÊñáÂπ∂Âà∑Êñ∞ÂàóË°®
      const deleteBtn = item.querySelector('.rune-delete');
      if (deleteBtn) {
        deleteBtn.addEventListener('click', () => {
          try {
            if (confirm(`Á°ÆËÆ§Âà†Èô§Á¨¶ÊñáÔºö${rune.name || 'Êú™ÂëΩÂêçÁ¨¶Êñá'}Ôºü`)) {
              if (runeManager && typeof runeManager.deleteRune === 'function') {
                runeManager.deleteRune(rune.id);
                updateRuneLibraryList();
              }
            }
          } catch (e) {
            console.error('Âà†Èô§Á¨¶ÊñáÂ§±Ë¥•:', e);
          }
        });
      }
      listEl.appendChild(item);
    });
  } catch (e) {
    console.error('Êõ¥Êñ∞Á¨¶ÊñáÂ∫ìÂàóË°®Â§±Ë¥•:', e);
  }
}

// Êñ∞Â¢ûÔºöÊòæÁ§∫Á¨¶ÊñáËØ¶ÊÉÖÔºà‰∏≠ÊñáÂèãÂ•ΩËßÜÂõæÔºâ
function displayRune(rune) {
  try {
    if (!rune) return;
    const detailContainer = document.getElementById('runeDetailContainer');
    const nameEl = document.getElementById('runeNameDetail');
    const idEl = document.getElementById('runeId');
    const intentEl = document.getElementById('intent');
    const essenceEl = document.getElementById('essence');
    const purposeEl = document.getElementById('purpose');
    const emotionEl = document.getElementById('emotion');
    const summaryEl = document.getElementById('summary');
    const jsonEls = document.querySelectorAll('pre#runeJSON');

    // Âç°ÁâáÂå∫ÂêåÊ≠•Âü∫Á°Ä‰ø°ÊÅØ
    const cardTitle = document.getElementById('cardTitle');
    const cardDesc = document.getElementById('cardDesc');
    const cardMeta = document.getElementById('cardMeta');
    if (cardTitle) cardTitle.textContent = rune.name || 'Êú™ÂëΩÂêçÁ¨¶Êñá';
    if (cardDesc) cardDesc.textContent = (rune.nineGrid && rune.nineGrid.metadata && rune.nineGrid.metadata.summary) || (rune.nineGrid && rune.nineGrid.content && rune.nineGrid.content.text) || '';
    if (cardMeta) cardMeta.textContent = `Á±ªÂûãÔºö${rune.type || 'Êú™Áü•'}ÔΩúÂàõÂª∫Ôºö${new Date((rune.meta && rune.meta.created) || Date.now()).toLocaleString('zh-CN')}`;

    // ËØ¶ÊÉÖÂå∫Â°´ÂÖÖ
    if (nameEl) nameEl.textContent = rune.name || 'Êú™ÂëΩÂêçÁ¨¶Êñá';
    if (idEl) idEl.textContent = `#${rune.id || 'rune_xxx'}`;
    const core = rune.nineGrid && rune.nineGrid.core ? rune.nineGrid.core : {};
    const meta = rune.nineGrid && rune.nineGrid.metadata ? rune.nineGrid.metadata : {};
    if (intentEl) intentEl.textContent = core.intent || '‚Äî';
    if (essenceEl) essenceEl.textContent = core.essence || '‚Äî';
    if (purposeEl) purposeEl.textContent = core.purpose || '‚Äî';
    if (emotionEl) emotionEl.textContent = meta.emotion || '‚Äî';
    if (summaryEl) summaryEl.textContent = meta.summary || 'ÊöÇÊó†ÊëòË¶Å';

    // JSONËßÜÂõæÔºà‰∏§‰∏™‰ΩçÁΩÆÈÉΩÂ°´ÂÖÖÔºåÈÅøÂÖçÈáçÂ§çIDÂÜ≤Á™ÅÈÄ†ÊàêÁöÑÁ©∫ÁôΩÔºâ
    const jsonString = JSON.stringify(rune, null, 2);
    jsonEls.forEach(el => { if (el) el.textContent = jsonString; });

    // Â±ïÁ§∫ËØ¶ÊÉÖÂÆπÂô®
    if (detailContainer) detailContainer.style.display = 'block';
  } catch (e) {
    console.error('ÊòæÁ§∫Á¨¶ÊñáËØ¶ÊÉÖÂ§±Ë¥•:', e);
  }
}

// Êñ∞Â¢ûÔºöÁªëÂÆöÂ∑•‰ΩúÂå∫‰∫ã‰ª∂ÔºàÊúÄÂ∞èÂèØÁî®ÂÆûÁé∞Ôºâ
function bindWorkspaceEvents() {
  try {
    const reloadBtn = document.getElementById('reloadWorkspaceBtn');
    if (reloadBtn) {
      reloadBtn.addEventListener('click', () => {
        updateRuneLibraryList();
        alert('‚úÖ Â∑≤ÈáçËΩΩÁ¨¶ÊñáÂ∫ì');
      });
    }
    const openBtn = document.getElementById('openWorkspaceBtn');
    if (openBtn) {
      openBtn.addEventListener('click', () => {
        alert('üîç ÊµèËßàÁ¨¶ÊñáÊñá‰ª∂ÊöÇÊú™ÂÆûÁé∞ÔºåÂêéÁª≠ÂØπÊé•Êñá‰ª∂Á≥ªÁªü');
      });
    }
    const selectBtn = document.getElementById('selectWorkspaceBtn');
    if (selectBtn) {
      selectBtn.addEventListener('click', () => {
        alert('üìÅ ÈÄâÊã©Â∑•‰ΩúÂå∫ÊöÇÊú™ÂÆûÁé∞ÔºåÂΩìÂâç‰ΩøÁî®Âõ∫ÂÆöË∑ØÂæÑ');
      });
    }
  } catch (e) {
    console.error('ÁªëÂÆöÂ∑•‰ΩúÂå∫‰∫ã‰ª∂Â§±Ë¥•:', e);
  }
}

// Ê≥®ÂÖ•ÔºöÂ∑•‰ΩúÂå∫Áä∂ÊÄÅÊõ¥Êñ∞ÊñπÊ≥ïÔºàÈÅøÂÖçÊú™ÂÆö‰πâÔºâ
(function injectWorkspaceStatusUpdater(){
  try {
    if (workspaceManager && typeof workspaceManager.updateWorkspaceStatus !== 'function') {
      workspaceManager.updateWorkspaceStatus = function() {
        const el = document.getElementById('workspaceStatus');
        if (el) {
          el.textContent = `Â∑•‰ΩúÂå∫Ôºö${this.currentPath || 'Êú™ÈÄâÊã©'}`;
        }
      };
    }
  } catch (e) {
    // ÂèØËÉΩÂú®ÂàùÂßãÂåñÂâçË∞ÉÁî®Ôºå‰∏çÂΩ±Âìç
  }
})();

// AI ËÅäÂ§©ÂÆ§ÂàùÂßãÂåñÔºàÂåÖÂê´Áî®Êà∑Êèê‰æõÁöÑÊâìÂºÄÂÖ≥Èó≠ÈÄªËæë‰∏éËÅäÂ§©‰∫§‰∫íÔºâ
function initAIChat() {
    const aiChatModal = document.getElementById('aiChatModal');
    const openAIChatBtn = document.getElementById('openAIChatBtn');
    const closeAIChatModal = document.getElementById('closeAIChatModal');
    const sendChatBtn = document.getElementById('sendChatBtn');
    const chatInput = document.getElementById('chatInput');
    const chatHistory = document.getElementById('chatHistory');

    if (!aiChatModal || !openAIChatBtn || !closeAIChatModal || !sendChatBtn || !chatInput || !chatHistory) {
        console.warn('AIËÅäÂ§©ÂÆ§ÂÖÉÁ¥†Êú™ÊâæÂà∞ÔºåË∑≥ËøáÂàùÂßãÂåñ');
        return;
    }

    // ÊâìÂºÄ AI ËÅäÂ§©ÂÆ§ÂºπÁ™ó
    openAIChatBtn.onclick = function() {
        aiChatModal.style.display = "block";
        setTimeout(() => chatInput.focus(), 100);
    };

    // ÂÖ≥Èó≠ AI ËÅäÂ§©ÂÆ§ÂºπÁ™ó
    closeAIChatModal.onclick = function() {
        aiChatModal.style.display = "none";
    };

    // ÁÇπÂáªÁ™óÂè£Â§ñÈÉ®ÂÖ≥Èó≠ÂºπÁ™ó
    window.addEventListener('click', function(event) {
        if (event.target === aiChatModal) {
            aiChatModal.style.display = "none";
        }
    });

    // EnterÂèëÈÄÅ„ÄÅShift+EnterÊç¢Ë°å
    sendChatBtn.onclick = sendMessage;
    chatInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });

    // Ëé∑ÂèñÂΩìÂâçÁ¨¶Êñá‰∏ä‰∏ãÊñáÔºàÂèñÊúÄÊñ∞Á¨¶ÊñáÔºâ
    function getCurrentRuneContext() {
        try {
            const runes = window.runeManager?.getAllRunes?.() || [];
            if (!runes.length) return null;
            const latestRune = runes[runes.length - 1];
            return {
                name: latestRune.name,
                intent: latestRune.nineGrid?.core?.intent,
                essence: latestRune.nineGrid?.core?.essence,
                summary: latestRune.nineGrid?.metadata?.summary
            };
        } catch (e) {
            console.warn('Ëé∑ÂèñÁ¨¶Êñá‰∏ä‰∏ãÊñáÂ§±Ë¥•:', e);
            return null;
        }
    }

    // Ê∑ªÂä†Ê∂àÊÅØ
    function addMessage(text, sender) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${sender}-message`;
        const content = document.createElement('p');
        content.textContent = text;
        messageDiv.appendChild(content);
        chatHistory.appendChild(messageDiv);
        scrollToBottom();
    }

    function scrollToBottom() {
        setTimeout(() => {
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }, 50);
    }

    // Ë∞ÉÁî®ÂêéÁ´Ø Gemini Êé•Âè£
    async function callAIChatAPI(message, context) {
        let prompt = '‰Ω†ÊòØ‰∏Ä‰∏™‰∏ì‰∏öÁöÑÁ¨¶ÊñáÂàÜÊûêÂä©Êâã„ÄÇËØ∑Ê†πÊçÆÁî®Êà∑ÁöÑÈóÆÈ¢òÊèê‰æõÊúâÂ∏ÆÂä©ÁöÑÂõûÁ≠î„ÄÇ';
        if (context) {
            prompt += `\n\nÂΩìÂâçÁ¨¶Êñá‰∏ä‰∏ãÊñáÔºö\n` +
                `Á¨¶ÊñáÂêçÁß∞Ôºö${context.name || ''}\n` +
                `Ê†∏ÂøÉÊÑèÂõæÔºö${context.intent || ''}\n` +
                `Êú¨Ë¥®Â±ûÊÄßÔºö${context.essence || ''}\n` +
                `ÊëòË¶ÅÊèèËø∞Ôºö${context.summary || ''}\n`;
        }
        prompt += `\nÁî®Êà∑ÈóÆÈ¢òÔºö${message}\n\nËØ∑Êèê‰æõ‰∏ì‰∏öÁöÑÂàÜÊûêÂíåÂª∫ËÆÆÔºö`;

        const resp = await fetch('/api/gemini/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ prompt, max_tokens: 500, temperature: 0.7 })
        });
        if (!resp.ok) throw new Error('AIÊúçÂä°ÂìçÂ∫îÈîôËØØ');
        const data = await resp.json();
        return data.text || data.response || 'AIÊ≤°ÊúâËøîÂõûÊúâÊïàÂõûÂ§ç';
    }

    // ÂèëÈÄÅÊ∂àÊÅØ
    async function sendMessage() {
        const message = chatInput.value.trim();
        if (!message) return;
        addMessage(message, 'user');
        chatInput.value = '';
        const context = getCurrentRuneContext();
        try {
            const reply = await callAIChatAPI(message, context);
            addMessage(reply, 'ai');
        } catch (error) {
            console.error('AIËÅäÂ§©ÈîôËØØ:', error);
            addMessage('Êä±Ê≠âÔºåAIÊúçÂä°ÊöÇÊó∂‰∏çÂèØÁî®ÔºåËØ∑Á®çÂêéÂÜçËØï„ÄÇ', 'ai');
        }
    }

    // ÂàùÂßãÂåñÂª∫ËÆÆ
    function addSmartSuggestions() {
        const suggestions = [
            'ÂàÜÊûêÂΩìÂâçÁ¨¶ÊñáÁöÑÊ†∏ÂøÉÊÑèÂõæ',
            'Ëß£ÈáäËøô‰∏™Á¨¶ÊñáÁöÑË±°ÂæÅÊÑè‰πâ',
            'Ëøô‰∏™Á¨¶ÊñáÈÄÇÂêà‰ªÄ‰πàÂú∫ÊôØ‰ΩøÁî®Ôºü',
            'Â¶Ç‰Ωï‰ºòÂåñËøô‰∏™Á¨¶ÊñáÁöÑË°®ËææÔºü'
        ];
        const suggestionsDiv = document.createElement('div');
        suggestionsDiv.className = 'chat-suggestions';
        suggestionsDiv.innerHTML = '<p>üí° ÊÇ®ÂèØËÉΩÊÉ≥ÈóÆÔºö</p>';
        suggestions.forEach(s => {
            const btn = document.createElement('button');
            btn.className = 'suggestion-btn';
            btn.textContent = s;
            btn.onclick = () => { chatInput.value = s; sendMessage(); };
            suggestionsDiv.appendChild(btn);
        });
        chatHistory.appendChild(suggestionsDiv);
    }

    setTimeout(() => {
        if (chatHistory.children.length <= 1) {
            addSmartSuggestions();
        }
    }, 300);
}

// Êñ∞Â¢ûÔºöÂµåÂÖ•ÂºèËÅäÂ§©ÂÆ§ÂàùÂßãÂåñÔºàÁ≤æÁÆÄÁâàÂ∏ÉÂ±Ä‰∏ìÁî®Ôºâ
function initEmbeddedChat() {
    console.log('üí¨ ÂàùÂßãÂåñÂµåÂÖ•ÂºèËÅäÂ§©ÂÆ§...');
    
    // Ëé∑ÂèñÂµåÂÖ•ÂºèËÅäÂ§©ÂÖÉÁ¥†
    const sendChatBtn = document.getElementById('sendChatBtn');
    const chatInput = document.getElementById('chatInput');
    const chatHistory = document.getElementById('chatHistory');
    
    if (!sendChatBtn || !chatInput || !chatHistory) {
        console.warn('ÂµåÂÖ•ÂºèËÅäÂ§©ÂÆ§ÂÖÉÁ¥†Êú™ÊâæÂà∞ÔºåË∑≥ËøáÂàùÂßãÂåñ');
        return;
    }
    
    // Ëé∑ÂèñÂΩìÂâçÁ¨¶Êñá‰∏ä‰∏ãÊñáÔºàÂèñÊúÄÊñ∞Á¨¶ÊñáÔºâ
    function getCurrentRuneContext() {
        try {
            const runes = window.runeManager?.getAllRunes?.() || [];
            if (!runes.length) return null;
            const latestRune = runes[runes.length - 1];
            return {
                name: latestRune.name,
                intent: latestRune.nineGrid?.core?.intent,
                essence: latestRune.nineGrid?.core?.essence,
                summary: latestRune.nineGrid?.metadata?.summary
            };
        } catch (e) {
            console.warn('Ëé∑ÂèñÁ¨¶Êñá‰∏ä‰∏ãÊñáÂ§±Ë¥•:', e);
            return null;
        }
    }
    
    // Ê∑ªÂä†Ê∂àÊÅØÂà∞ËÅäÂ§©ÂéÜÂè≤
    function addMessage(text, sender) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${sender}-message`;
        messageDiv.textContent = text;
        chatHistory.appendChild(messageDiv);
        scrollToBottom();
    }
    
    // ÊªöÂä®Âà∞Â∫ïÈÉ®
    function scrollToBottom() {
        setTimeout(() => {
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }, 50);
    }
    
    // Ë∞ÉÁî®ÂêéÁ´Ø Gemini Êé•Âè£
    async function callAIChatAPI(message, context) {
        let prompt = '‰Ω†ÊòØ‰∏Ä‰∏™‰∏ì‰∏öÁöÑÁ¨¶ÊñáÂàÜÊûêÂä©Êâã„ÄÇËØ∑Ê†πÊçÆÁî®Êà∑ÁöÑÈóÆÈ¢òÊèê‰æõÊúâÂ∏ÆÂä©ÁöÑÂõûÁ≠î„ÄÇ';
        if (context) {
            prompt += `\n\nÂΩìÂâçÁ¨¶Êñá‰∏ä‰∏ãÊñáÔºö\n` +
                `Á¨¶ÊñáÂêçÁß∞Ôºö${context.name || ''}\n` +
                `Ê†∏ÂøÉÊÑèÂõæÔºö${context.intent || ''}\n` +
                `Êú¨Ë¥®Â±ûÊÄßÔºö${context.essence || ''}\n` +
                `ÊëòË¶ÅÊèèËø∞Ôºö${context.summary || ''}\n`;
        }
        prompt += `\nÁî®Êà∑ÈóÆÈ¢òÔºö${message}\n\nËØ∑Êèê‰æõ‰∏ì‰∏öÁöÑÂàÜÊûêÂíåÂª∫ËÆÆÔºö`;
        
        try {
            const resp = await fetch('/api/gemini/generate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt, max_tokens: 500, temperature: 0.7 })
            });
            if (!resp.ok) throw new Error('AIÊúçÂä°ÂìçÂ∫îÈîôËØØ');
            const data = await resp.json();
            return data.text || data.response || 'AIÊ≤°ÊúâËøîÂõûÊúâÊïàÂõûÂ§ç';
        } catch (error) {
            console.error('AIËÅäÂ§©APIË∞ÉÁî®Â§±Ë¥•:', error);
            // ËøîÂõûÊ®°ÊãüÂõûÂ§çÔºåÁ°Æ‰øùÁî®Êà∑‰ΩìÈ™å
            return 'ÊàëÁêÜËß£ÊÇ®ÁöÑÈóÆÈ¢ò„ÄÇ‰ªéÁ¨¶ÊñáÁöÑËßíÂ∫¶Êù•ÁúãÔºåËøôÊ∂âÂèäÂà∞Ê∑±Â±ÇÁöÑË±°ÂæÅÊÑè‰πâÂíåËÉΩÈáèÊµÅÂä®„ÄÇÂª∫ËÆÆÊÇ®ÁªìÂêàÂΩìÂâçÁöÑÁ¨¶Êñá‰∏ä‰∏ãÊñáËøõË°åÊõ¥Ê∑±ÂÖ•ÁöÑÊÄùËÄÉ„ÄÇ';
        }
    }
    
    // ÂèëÈÄÅÊ∂àÊÅØ
    async function sendMessage() {
        const message = chatInput.value.trim();
        if (!message) return;
        
        // Ê∑ªÂä†Áî®Êà∑Ê∂àÊÅØ
        addMessage(message, 'user');
        chatInput.value = '';
        
        // Ëé∑ÂèñÁ¨¶Êñá‰∏ä‰∏ãÊñá
        const context = getCurrentRuneContext();
        
        try {
            // Ë∞ÉÁî®AIÊé•Âè£
            const reply = await callAIChatAPI(message, context);
            addMessage(reply, 'ai');
        } catch (error) {
            console.error('AIËÅäÂ§©ÈîôËØØ:', error);
            addMessage('Êä±Ê≠âÔºåAIÊúçÂä°ÊöÇÊó∂‰∏çÂèØÁî®ÔºåËØ∑Á®çÂêéÂÜçËØï„ÄÇ', 'ai');
        }
    }
    
    // ÁªëÂÆöÂèëÈÄÅÊåâÈíÆ‰∫ã‰ª∂
    sendChatBtn.onclick = sendMessage;
    
    // ÁªëÂÆöÂõûËΩ¶ÂèëÈÄÅ‰∫ã‰ª∂ÔºàEnterÂèëÈÄÅÔºåShift+EnterÊç¢Ë°åÔºâ
    chatInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    // Ê∑ªÂä†Êô∫ËÉΩÂª∫ËÆÆ
    function addSmartSuggestions() {
        const suggestions = [
            'ÂàÜÊûêÂΩìÂâçÁ¨¶ÊñáÁöÑÊ†∏ÂøÉÊÑèÂõæ',
            'Ëß£ÈáäËøô‰∏™Á¨¶ÊñáÁöÑË±°ÂæÅÊÑè‰πâ',
            'Ëøô‰∏™Á¨¶ÊñáÈÄÇÂêà‰ªÄ‰πàÂú∫ÊôØ‰ΩøÁî®Ôºü',
            'Â¶Ç‰Ωï‰ºòÂåñËøô‰∏™Á¨¶ÊñáÁöÑË°®ËææÔºü'
        ];
        const suggestionsDiv = document.createElement('div');
        suggestionsDiv.className = 'chat-suggestions';
        suggestionsDiv.innerHTML = '<p>üí° ÊÇ®ÂèØËÉΩÊÉ≥ÈóÆÔºö</p>';
        suggestions.forEach(s => {
            const btn = document.createElement('button');
            btn.className = 'suggestion-btn';
            btn.textContent = s;
            btn.onclick = () => { 
                chatInput.value = s; 
                sendMessage(); 
            };
            suggestionsDiv.appendChild(btn);
        });
        chatHistory.appendChild(suggestionsDiv);
    }
    
    // Âª∂ËøüÊ∑ªÂä†Êô∫ËÉΩÂª∫ËÆÆ
    setTimeout(() => {
        if (chatHistory.children.length <= 1) {
            addSmartSuggestions();
        }
    }, 1000);
    
    console.log('‚úÖ ÂµåÂÖ•ÂºèËÅäÂ§©ÂÆ§ÂàùÂßãÂåñÂÆåÊàê');
}

// DOMContentLoaded ‰∏≠Ë∞ÉÁî®
document.addEventListener('DOMContentLoaded', function() {
    console.log('üöÄ DOMÂÜÖÂÆπÂä†ËΩΩÂÆåÊàêÔºåÂºÄÂßãÂàùÂßãÂåñAIËÅäÂ§©...');
    // Ê≥®ÊÑèÔºöÂéüÊúâÁöÑinitAIChat()Â∑≤Ë¢´initEmbeddedChat()Êõø‰ª£
    initEmbeddedChat();
    try {
      // ‰øùÁïôÂéüÊúâÁöÑÈ¶ñÊ¨°Ê∏≤ÊüìÁ¨¶ÊñáÂ∫ìÈÄªËæë
      updateRuneLibraryList();
    } catch (e) {
      console.warn('ÂàùÂßãÂåñÁ¨¶ÊñáÂ∫ìÊ∏≤ÊüìÂ§±Ë¥•:', e);
    }
    // ... ÂÖ∂‰ªñÁé∞ÊúâÂàùÂßãÂåñ‰ª£Á†Å ...
});
